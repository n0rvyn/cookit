---
name: generating-vf-prompts
description: "Use when a plan is written or code changes are complete and the user wants a verification prompt. Generates a Verification-First prompt with falsifiable assertions."
disable-model-invocation: true
---

## 触发时机

- 计划写完后，想生成验证提示词
- 代码写完后，想生成 review 提示词
- 任何时候想要一条针对当前工作的 VF prompt

## 流程

### 1. 语境分析

**自动检测**，不问用户：

读取以下信号判断当前阶段和内容类型：

| 信号 | 判断 |
|------|------|
| 会话中存在未执行的计划（plan mode 产出或 markdown 计划） | 阶段 = 计划验证 |
| 存在近期代码变更（git diff 有内容） | 阶段 = 实现验证 |
| 计划/变更涉及 View/UI/样式/布局 | 内容 = UI |
| 计划/变更涉及 Service/Agent/Tool/数据流/事件入口 | 内容 = 架构 |
| 计划/变更步骤 ≥ 5 且有依赖关系 | 内容 = 多步骤 |
| 计划/变更修改已有代码的行为 | 内容 = 功能变更 |

### 2. 策略选择

根据语境自动选择（可重叠）：

| 阶段 + 内容 | 策略 |
|-------------|------|
| 计划验证 + 功能变更 | S1（具体候选错误） |
| 计划验证 + 架构 | S1 + S3（对抗性角色） |
| 计划验证 + UI | S1 + U1（token一致性）+ U2（极端渲染） |
| 计划验证 + 多步骤 | S2（失败反向推理） |
| 实现验证 + 任意 | R1（运行时 regression 推理） |

### 3. 生成 VF Prompt

**核心要求**：prompt 中的每条断言必须基于实际代码库内容生成，不可使用通用模板。

执行步骤：
1. 读取计划内容或 `git diff` 变更内容
2. 读取变更涉及的关键文件（被修改的文件、被引用的文件）
3. 基于实际代码生成 3-5 条具体的、可证伪的断言
4. 组装成完整 prompt

---

## Prompt 模板

根据策略选择对应模板，填充实际内容后输出。

### S1 - 具体候选错误（功能变更）

```
以下是对这个计划的外部审查意见，逐条验证是否成立（引用代码库中的具体文件:行号），成立则更新计划：

1. {基于实际代码生成的断言1，格式："步骤 N 的 [具体操作] 会导致 [具体文件] 中的 [具体函数/引用] 断裂/失效，因为 [具体原因]"}
2. {断言2}
3. {断言3}
[4-5 条可选]

验证完以上断言后，检查是否存在这些审查未覆盖的同类问题。
```

### S2 - 失败反向推理（多步骤）

```
假设这个计划已全部执行完毕：

1. Build 失败了。基于步骤间的依赖关系，最可能的编译错误是什么？具体是哪个步骤产生的、报错在哪个文件？
2. Build 通过了，但用户执行 [计划涉及的核心用户操作] 时遇到了 regression。从用户操作路径反向追溯到代码变更点，最可能的 regression 是什么？

对每个推理结果，引用计划中的具体步骤说明是否已覆盖。未覆盖的需要更新计划。
```

### S3 - 对抗性角色分离（架构）

```
一个熟悉这个代码库的 tech lead 审查了这个计划，给出以下反馈：

1. "{基于实际代码生成的架构级断言1，如：'[新入口] 和现有的 [已有入口 file:line] 是两条独立路径调用同一个 [核心函数]，计划没有说明协调机制'}"
2. "{断言2，如：'[被替代的组件] 在 [file:line] 和 [file:line] 还有引用，计划的替代清单不完整'}"
3. "{断言3，如：'步骤 N 修改了 [Model] 的字段，但 [消费该字段的 file:line] 的 switch/if 没有处理新增的情况'}"

逐条验证每条反馈（引用代码中的具体文件:行号），成立则更新计划。
```

### U1 - Token 一致性（UI）

```
验证这个计划中所有 UI 相关步骤：

1. 列出每个步骤会用到的尺寸、间距、颜色、字号
2. 对每个值，在 {项目 DesignTokens 文件路径} 中查找对应 token
3. 对比 {已有同类组件路径} 的间距/颜色/圆角模式，标注新组件与已有组件的不一致之处

输出表格：| 步骤 | UI 值 | Token | 状态 |
缺失项和不一致项需要在计划中补充。
```

### U2 - 极端渲染条件（UI）

```
假设这个计划实现完毕，一个用户在以下条件打开了这个界面：
- Dynamic Type 设为 AX5（最大辅助字号）
- Dark Mode
- iPhone SE（最小屏幕）
- {基于计划内容填充的具体数据条件，如："列表有 50 条数据" 或 "文本为 500 字中文"}

逐个走过计划中的每个 UI 组件：哪个会溢出？哪个文本会被截断？哪个间距会挤压到不可用？引用计划中的具体步骤说明问题和修复方案。
```

### R1 - 运行时 Regression（实现验证）

```
以下代码变更已完成（基于 git diff）：

{列出关键变更摘要：文件名 + 改了什么}

假设一个用户执行 [变更涉及的核心操作]，但遇到了一个 bug（不是编译错误，是运行时行为异常）。

1. 最可能的 bug 是什么？从用户操作反向追溯到变更的代码行
2. 变更是否影响了未被修改但依赖同一数据/状态的其他功能？
3. 冷启动（首次打开 app）vs 热路径（已有数据）下，变更的行为是否一致？

每条引用具体 file:line。
```

---

## 4. 输出

输出格式：

````
## VF Prompt

**语境**: {阶段} + {内容类型}
**策略**: {选中的策略名称}

---

**复制以下内容使用：**

```
{生成的完整 prompt}
```

---

此 prompt 基于当前代码库状态生成。如果代码有新变更，重新运行 `/generating-vf-prompts` 获取更新版本。
````

## 原则

1. **断言必须代码锚定**：每条断言必须基于实际读取的代码文件内容生成，禁止使用通用占位符
2. **具体 > 全面**：3 条具体断言好过 10 条泛泛断言
3. **只生成不执行**：本命令只输出 prompt，不执行验证。验证是用户粘贴 prompt 后的事
4. **策略可组合**：当语境命中多个策略时，合并为一条 prompt（不输出多条）
5. **断言方向多样**：同一 prompt 中的多条断言应覆盖不同维度（集成/状态/删除/依赖），不重复同一类型
