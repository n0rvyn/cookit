---
name: generating-df-prompts
description: "Use when a plan has been generated from a design document and the user wants to verify the plan faithfully covers the design. Generates a Design Faithfulness prompt."
disable-model-invocation: true
---

## 定位

与 VF-Prompt 互补，两者串联使用：

```
设计文档 → [DF-Prompt: 忠实度+完备度] → 计划 → [VF-Prompt: 缺陷+回归] → 执行
```

- **DF-Prompt**：确保"做对的事"（计划忠实于设计文档）
- **VF-Prompt**：确保"把事做对"（计划/代码技术正确）

## 触发时机

- 从设计文档生成计划后，想验证计划是否忠实于设计
- 计划修改后，想验证修改没有偏离设计意图
- 任何时候想要一条针对"设计→计划"的忠实度检查 prompt

## 流程

### 1. 语境分析

**自动检测**，不问用户：

读取以下信号判断内容类型和验证重点：

| 信号 | 判断 |
|------|------|
| 会话中存在设计文档/PRD/需求文档 | 来源 = 设计文档 |
| 会话中存在已生成的计划 | 目标 = 实施计划 |
| 设计文档有明确的步骤/流程描述 | 重点 += 粒度审计 |
| 设计文档有前置条件/约束/假设 | 重点 += 隐含上下文 |
| 计划步骤数明显少于设计文档要求数 | 重点 += 完备度 |
| 计划包含设计文档未提及的决策 | 重点 += 幻觉检测 |

### 2. 策略选择

根据语境自动选择（可重叠）：

| 重点 | 策略 |
|------|------|
| 所有场景（必选） | D1（双向映射） |
| 计划步骤数 < 设计要求数 | D1 + D4（粒度审计） |
| 计划包含设计文档外的决策 | D1 + D2（幻觉检测） |
| 设计文档有隐含前提/业务规则 | D1 + D3（隐含上下文提取） |
| 设计文档含边界场景/异常流程 | D1 + D5（边界场景覆盖） |

### 3. 生成 DF Prompt

**核心要求**：prompt 中的每条断言必须基于实际设计文档内容和计划内容生成，不可使用通用模板。

执行步骤：
1. 读取设计文档内容（会话中的文档、附件、或用户指定的文件）
2. 读取已生成的计划内容
3. 提取设计文档中的所有要求、约束、前提条件
4. 与计划步骤进行双向对照
5. 基于实际差异生成 3-5 条具体的、可证伪的断言
6. 组装成完整 prompt

---

## Prompt 模板

根据策略选择对应模板，填充实际内容后输出。

### D1 - 双向映射（所有场景必选）

```
一位需求分析师对照设计文档审查了这份计划，建立了以下追溯关系。逐条验证是否成立，成立则更新计划：

[完备度：设计→计划]
1. 设计文档 {章节/段落引用} 要求 {具体要求原文}，但计划中没有对应步骤覆盖这一要求
2. {断言2}

[忠实度：计划→设计]
3. 计划步骤 {N} 中 {具体操作} 对设计文档 {章节} 的 {具体要求} 做了变形处理，原文要求是 {原文}，计划改为 {计划表述}
4. {断言4}

验证完以上断言后，建立完整的双向追溯表：
| 设计要求 | 计划步骤 | 状态 |
每行状态标注为：✅ 覆盖 / ❌ 未覆盖 / ⚠️ 偏离
```

### D2 - 幻觉检测（计划超出设计授权）

```
一位需求分析师标注了这份计划中找不到设计文档依据的决策。逐条验证（引用设计文档的具体章节），确认是"设计留白需要用户决定"还是"设计文档已有要求但被忽略"：

1. 计划步骤 {N} 决定了 {具体决策}，但设计文档在 {相关章节} 未授权这一决策。设计文档原文是：{引用}
2. 计划步骤 {N} 引入了 {具体技术选型/交互方式/默认值}，设计文档未涉及此选择
3. {断言3}

对每个未授权决策，标注处置方式：
- 设计留白 → 需要问用户
- 设计已有要求 → 更新计划以匹配设计
- 合理的实现细节补充 → 保留但标注"实现决策"
```

### D3 - 隐含上下文提取（前提条件和约束）

```
一位需求分析师从设计文档中提取了以下隐含前提和约束条件，但在计划中未找到对应体现。逐条验证：

[隐含前提]
1. 设计文档 {章节} 的 {表述} 隐含前提：{提取的前提条件}。计划未在任何步骤中体现这一约束
2. {断言2}

[业务规则]
3. 设计文档 {章节} 描述了业务规则 {规则内容}，但计划步骤 {N} 的实现未考虑这一规则
4. {断言4}

验证完后，列出设计文档中所有隐含假设，逐一确认计划是否已覆盖。
```

### D4 - 粒度审计（步骤合并/拆分检查）

```
一位需求分析师对比了设计文档和计划的步骤粒度，发现以下不匹配。逐条验证：

[不当合并]
1. 设计文档 {章节} 描述了 {A → B → C} 三个阶段，计划将其合并为步骤 {N} 一步完成，丢失了 {B 阶段的约束条件/中间检查点}
2. {断言2}

[不当拆分]
3. 设计文档 {章节} 将 {X} 作为一个原子操作描述，计划拆分为步骤 {N} 和 {M}，引入了中间状态 {状态描述}，但设计文档未考虑这一中间状态

对每个粒度不匹配，说明：合并/拆分导致丢失了什么约束或引入了什么风险？
```

### D5 - 边界场景覆盖（异常流程和极端条件）

```
一位需求分析师从设计文档中提取了以下边界场景和异常流程，但在计划中未找到对应处理。逐条验证：

1. 设计文档 {章节} 提到 {边界场景描述}，但计划步骤 {N} 只处理了正常流程，未覆盖此场景
2. 设计文档 {章节} 的 {要求} 在 {极端条件} 下的行为未在计划中定义
3. {断言3}

验证完后，检查设计文档中是否还有其他边界场景/异常流程/错误处理要求未被计划覆盖。
```

---

## 4. 输出

输出格式：

````
## DF Prompt

**来源**: {设计文档名称/位置}
**目标**: {计划名称/位置}
**策略**: {选中的策略名称}

---

**复制以下内容使用：**

```
{生成的完整 prompt}
```

---

此 prompt 基于当前设计文档和计划内容生成。如果文档有更新，重新运行 `/generating-df-prompts` 获取更新版本。
````

## 原则

1. **断言必须文档锚定**：每条断言必须引用设计文档的具体章节/段落和计划的具体步骤，禁止使用通用占位符
2. **双向检查 > 单向检查**：D1 双向映射是必选策略，确保不遗漏任何方向的差异
3. **区分"设计留白"和"计划遗漏"**：设计文档未提及的不等于不需要，需要标注让用户决定
4. **角色是需求分析师，不是 tech lead**：关注"是否忠实于设计意图"，不关注"技术实现是否正确"（后者是 VF-Prompt 的职责）
5. **只生成不执行**：本命令只输出 prompt，不执行验证
6. **策略可组合**：当语境命中多个策略时，合并为一条 prompt（不输出多条）
7. **具体 > 全面**：3 条具体断言好过 10 条泛泛断言
